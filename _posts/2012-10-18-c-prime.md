---
layout: post
title: "c++ prime"
description: ""
category: "clanguage work"
tags: []
sumarry: |
  &lt;&lt;C++ Primer>>这本书,以前有看过,但是没有认真看完,只是稍微翻翻.今日,有重新翻开看,感觉这本书真的很棒.本文的目的就是在于记录看这本书的各种收获.
---
{% include JB/setup %}

####摘要

<<C++ Primer>>这本书,以前有看过,但是没有认真看完,只是稍微翻翻.今日,有重新翻开看,感觉这本书真的很棒.本文的目的就是在于记录看这本书的各种收获.


####目录


1. [const 限定符](#a1)
2. [引用是别名](#a2)
3. [指针与引用区别](#a3)
4. [指针与const] (#a4)
5. [c++ extern] (#a5)




<a name="a1"> </a>

####1. const 限定符

###const 对象默认为文件的局部变量
在全局作用域里定义非 const 变量时，它在整个程序中都
可以访问。我们可以把一个非 const 变更定义在一个文件中，假设已经做了合
适的声明，就可在另外的文件中使用这个变量：

<pre class="brush: js;">
// file_1.cc
int counter; // definition
// file_2.cc
extern int counter; // uses counter from file_1
++counter; // increments counter defined in file_1
</pre>

与其他变量不同，除非特别说明，在全局作用域声明的 const 变量是定义
该对象的文件的局部变量。此变量只存在于那个文件中，不能被其他文件访问。
通过指定 const 变更为 extern，就可以在整个程序中访问 const 对象：

<pre class="brush: js;">
// file_1.cc
// defines and initializes a const that is accessible to other files
extern const int bufSize = fcn();
// file_2.cc
extern const int bufSize; // uses bufSize from file_1
// uses bufSize defined in file_1
for (int index = 0; index != bufSize; ++index)
// ...
</pre>

本程序中，file_1.cc 通过函数 fcn 的返回值来定义和初始化 bufSize。
而 bufSize 定义为 extern，也就意味着 bufSize 可以在其他的文件中使用。
file_2.cc 中 extern 的声明同样是 extern；这种情况下，extern 标志着
bufSize 是一个声明，所以没有初始化式。


<div class="ymy_div">
<p class="triangle-isosceles top">非 const 变量默认为 extern。要使 const 变量能够在其他的
文件中访问，必须地指定它为 extern.</p>
</div>



<a name="a2"> </a>

####2. 引用是别名

### 引用是别名

<p>引用就是对象的另一个名字。在实际程序中，引用主要用作函数的形式参数.
引用是一种复合类型，通过在变量名前添加“&amp;”符号来定义。复合类型是
指用其他类型定义的类型。在引用的情况下，每一种引用类型都“关联到”某一
其他类型。</p>

<div class="ymy_div">
<p class="triangle-isosceles left">不能定义引用类型的引用，但可以定义任何其他类型的引用。
引用必须用与该引用同类型的对象初始化：</p>
</div>

<pre class="brush: js;">
int ival = 1024;
int &amp;refVal = ival; // ok: refVal refers to ival
int &amp;refVal2; // error: a reference must be initialized
int &amp;refVal3 = 10; // error: initializer must be an object
</pre>

因为引用只是它绑定的对象的另一名字，作用在引用上的所有操作事实上都
是作用在该引用绑定的对象上：
<pre class="brush: js;">
    refVal += 2;
</pre>
将 refVal 指向的对象 ival 加 2。类似地，
<pre class="brush: js;">
    int ii = refVal;
</pre>
把和 ival 相关联的值赋给 ii。
当引用初始化后，只要该引用存在，它就保持绑定到初始化时
指向的对象。不可能将引用绑定到另一个对象。
要理解的重要概念是引用只是对象的另一名字。事实上，我们可以通过 ival
的原名访问 ival，也可以通过它的别名 refVal 访问。赋值只是另外一种操作，
因此我们编写
<pre class="brush: js;">
refVal = 5;
</pre>
的效果是把 ival 的值修改为5。这一规则的结果是必须在定义引用时进行初始
化。
<div class="ymy_div">
<p class="triangle-isosceles right">初始化是指明引用指向哪个对象的唯一方法。</p>
</div>

### const 引用

const 引用是指向 const 对象的引用：
<pre class="brush: js;">
const int ival = 1024;
const int &amp;refVal = ival; // ok: both reference and object are const
int &amp;ref2 = ival; // error: non const reference to a const object
</pre>

可以读取但不能修改 refVal ，因此，任何对 refVal 的赋值都是不合法的。这
个限制有其意义：不能直接对 ival 赋值，因此不能通过使用 refVal 来修改
ival。
同理，用 ival 初始化 ref2 也是不合法的：ref2 是普通的非 const 引用，因
此可以用来修改 ref2 指向的对象的值。通过 ref2 对 ival 赋值会导致修改
const 对象的值。为阻止这样的修改，需要规定将普通的引用绑定到 const 对
象是不合法的。



<div class="ymy_div">
<p class="triangle-isosceles right">C++ 程序员常常随意地使用术语 const 引用。严格来说，“const 引
用”的意思是“指向 const 对象的引用”。类似地，程序员使用术语“非 const 引用”表示指向非 const 类型的引用。这种用法非常普遍，我们在本书中也遵循这种用法。</p>
</div>

const 引用可以初始化为不同类型的对象或者初始化为右值，如字面值常量：

<pre class="brush: js;">
int i = 42;
// legal for const references only
const int &amp;r = 42;
const int &amp;r2 = r + i;
</pre>

同样的初始化对于非 const 引用却是不合法的，而且会导致编译时错误。
其原因非常微妙，值得解释一下。
观察将引用绑定到不同的类型时所发生的事情，最容易理解上述行为。假如我们
编写

<pre class="brush: js;">
double dval = 3.14;
const int &amp;ri = dval;
</pre>

编译器会把这些代码转换成如以下形式的编码：

<pre class="brush: js;">
int temp = dval; // create temporary int from the double
const int &amp;ri = temp; // bind ri to that temporary
</pre>

如果 ri 不是 const，那么可以给 ri 赋一新值。这样做不会修改 dval，
而是修改了 temp。期望对 ri 的赋值会修改 dval 的程序员会发现 dval 并没
有被修改。仅允许 const 引用绑定到需要临时使用的值完全避免了这个问题，
因为 const 引用是只读的。


<div class="ymy_div">
<p class="triangle-isosceles right">非 const 引用只能绑定到与该引用同类型的对象。const 引用则可以绑定到不同但相关的类型的对象或绑定到右值。</p>
</div>


<a name="a3"> </a>

####3. 指针与引用区别


<div class="ymy_div">
<p class="triangle-isosceles botton">指针与引用的区别：第一个重要的区别在于引用总是指向某个对象：定义引用时没有初始化是错误的。</p>
</div>


<div class="ymy_div">
<p class="triangle-isosceles left">指针与引用的区别：第二个重要的区别在于赋值行为的差异：给引用赋值修改的是该引用所关联的对象的值，而不是使引用与另一个对象关联。引用一旦初始化，就始终指向同一个特定对象。（这也是为何引用必须在定义的时候初始化的原因）</p>
</div>


<a name="a4"> </a>

####4. 指针与const

###指向const对象的指针

<div class="ymy_div">
<p class="triangle-isosceles left">不能使用指向const对象的指针来修改基础对象，然而如果该指针指向的是一个非const对象，可以用其他的方法修改所指的对象。</p>
</div>

<div class="ymy_div">
<p class="triangle-isosceles top">上面的法则告诉我们： 没有办法保证指向const的指针所指的对象的值一定不可以修改。</p>
</div>

###const指针


<pre class="brush: js;">
int errNumb = 0;
int * const curErr = &amp;errNumb;
curErr = curErr; //error: curErr is const
</pre>

与其他的const量一样，const指针也必须在定义的时候初始化。


###指针与typedef

个人对typedef的理解还是很肤浅，当看到这本书关于这一点的介绍的时候，茅塞顿开。

<pre class="brush: js;">
typedef string * pstring;
const pstring cstr;
</pre>

各位，这里cstr到底代表的是一个什么样子的数据类型呢？我刚刚开始也错了，原因在于我将typedef进行字符替换的方式进行思考。因此，我认为pstring类型是指向const的string指针。但是，其实不是的，这里的const修饰的是cstr，而不是string \*，因此上面的实质应该是这样的。

<pre class="brush: js;">
string * const cstr;
</pre>

怎么样，是不是傻了眼？





<a name="a5"> </a> 

####5. [c++ extern] (#a5)

#####












