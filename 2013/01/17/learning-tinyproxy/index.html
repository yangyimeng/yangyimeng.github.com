
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8" />
   <title>Learning tinyproxy &larr; </title>
   <meta name="author" content="YiMeng Yang" />

   <link rel="start" href="/" />

	
	
	
  	<link rel="alternate" type="application/atom+xml" href="http://feeds.feedburner.com/feedname" title="RSS feed" />
	
	



   <!-- Homepage CSS -->
   <link rel="stylesheet" href="/assets/themes/mark-reid/css/pygments.css" type="text/css" />
   <!-- Homepage CSS -->
   <link rel="stylesheet" href="/assets/themes/mark-reid/css/syntax.css" type="text/css" />   
   <!-- Homepage CSS -->
   <link rel="stylesheet" href="/assets/themes/mark-reid/css/screen.css" type="text/css" />
<style>
.ymy_div {
  width: 100%;
  height: 100px;
  margin-bottom: 40px;
}


.triangle-isosceles {
  position:relative;
  padding:15px;
  margin:1em 0 3em;
  color:#000;
  background:#EEE; /* default background for browsers without gradient support */
  /* css3 */
  background:-webkit-gradient(linear, 0 0, 0 100%, from(#EEE), to(#EEE));
  background:-moz-linear-gradient(#EEE, #EEE);
  background:-o-linear-gradient(#EEE, #EEE);
  background:linear-gradient(#EEE, #EEE);
  -webkit-border-radius:10px;
  -moz-border-radius:10px;
  border-radius:10px;
}

/* Variant : for top positioned triangle
------------------------------------------ */

.triangle-isosceles.top {
  background:-webkit-gradient(linear, 0 0, 0 100%, from(#EEE), to(#EEE));
  background:-moz-linear-gradient(#EEE, #EEE);
  background:-o-linear-gradient(#EEE, #EEE);
  background:linear-gradient(#EEE, #EEE);
}

/* Variant : for left/right positioned triangle
------------------------------------------ */

.triangle-isosceles.left {
  margin-left:50px;
  background:#EEE;
}

/* Variant : for right positioned triangle
------------------------------------------ */

.triangle-isosceles.right {
  margin-right:50px;
  background:#EEE;
}

/* THE TRIANGLE
------------------------------------------------------------------------------------------------------------------------------- */

/* creates triangle */
.triangle-isosceles:after {
  content:"";
  position:absolute;
  bottom:-15px; /* value = - border-top-width - border-bottom-width */
  left:50px; /* controls horizontal position */
  border-width:15px 15px 0; /* vary these values to change the angle of the vertex */
  border-style:solid;
  border-color:#EEE transparent;
    /* reduce the damage in FF3.0 */
    display:block; 
    width:0;
}

/* Variant : top
------------------------------------------ */

.triangle-isosceles.top:after {
  top:-15px; /* value = - border-top-width - border-bottom-width */
  right:50px; /* controls horizontal position */
  bottom:auto;
  left:auto;
  border-width:0 15px 15px; /* vary these values to change the angle of the vertex */
  border-color:#EEE transparent;
}

/* Variant : left
------------------------------------------ */

.triangle-isosceles.left:after {
  top:16px; /* controls vertical position */
  left:-50px; /* value = - border-left-width - border-right-width */
  bottom:auto;
  border-width:10px 50px 10px 0;
  border-color:transparent #EEE;
}

/* Variant : right
------------------------------------------ */

.triangle-isosceles.right:after {
  top:16px; /* controls vertical position */
  right:-50px; /* value = - border-left-width - border-right-width */
  bottom:auto;
  left:auto;
  border-width:10px 0 10px 50px;
  border-color:transparent #EEE;
}


#top-link {
    PADDING-RIGHT: 10px;     
    PADDING-LEFT: 10px; 
    FONT-WEIGHT: bold; 
    
    BACKGROUND: whiteSmoke; 
    PADDING-BOTTOM: 10px;
    filter:alpha(opacity=20);
    opacity:.2; 
    BOTTOM: 5px; 
    PADDING-TOP: 10px;     
    POSITION: fixed; 
    TEXT-DECORATION: none
}



</style>
  <script type="text/javascript" src="/assets/themes/mark-reid/scripts/miaov.js"></script>
  <script type="text/javascript" src="/assets/themes/mark-reid/scripts/shCore.js"></script>
  <script type="text/javascript" src="/assets/themes/mark-reid/scripts/shBrushJScript.js"></script>
  <link type="text/css" rel="stylesheet" href="/assets/themes/mark-reid/styles/shCoreDefault.css"/>
 <link type="text/css" rel="stylesheet" href="/assets/themes/mark-reid/styles/miaov_style.css"/>
 <script type="text/javascript">

    SyntaxHighlighter.all();
/**
 * 回到页面顶部
 * @param acceleration 加速度
 * @param time 时间间隔 (毫秒)
 **/
function goTop(acceleration, time) {
    acceleration = acceleration || 0.1;
    time = time || 16;
 
    var x1 = 0;
    var y1 = 0;
    var x2 = 0;
    var y2 = 0;
    var x3 = 0;
    var y3 = 0;
 
    if (document.documentElement) {
        x1 = document.documentElement.scrollLeft || 0;
        y1 = document.documentElement.scrollTop || 0;
    }
    if (document.body) {
        x2 = document.body.scrollLeft || 0;
        y2 = document.body.scrollTop || 0;
    }
    var x3 = window.scrollX || 0;
    var y3 = window.scrollY || 0;
 
    // 滚动条到页面顶部的水平距离
    var x = Math.max(x1, Math.max(x2, x3));
    // 滚动条到页面顶部的垂直距离
    var y = Math.max(y1, Math.max(y2, y3));
 
    // 滚动距离 = 目前距离 / 速度, 因为距离原来越小, 速度是大于 1 的数, 所以滚动距离会越来越小
    var speed = 1 + acceleration;
    window.scrollTo(Math.floor(x / speed), Math.floor(y / speed));
 
    // 如果距离不为零, 继续调用迭代本函数
    if(x > 0 || y > 0) {
        var invokeFunction = "goTop(" + acceleration + ", " + time + ")";
        window.setTimeout(invokeFunction, time);
    }
}

 </script>

</head>
<body id="">
<div id="site">
  
  <div id="header">
    <h1>
    	<a href="/" title="Jekyll Bootstrap">Jekyll Bootstrap</a>
    	<span class="byline">&larr; <a href="/">YiMeng Yang</a></span>
    </h1>
    <ul class="nav">
      <li><a class="home" href="/">Home</a></li>
      <li><a  href="/life.html">Life</a></li>
      <li><a  href="/work.html">Work</a></li>
      <li><a  href="/about.html">About</a></li>
      <li><a  href="/other.html">Other</a></li>
    </ul>
  </div>

  
<div id="page">
	
  <h1 class="emphnext">Learning tinyproxy</h1>


  <h4 id='abstract'>Abstract</h4>

<p>In this paper, I just want to record my learning of tinyproxy source code.Just for it!</p>

<h4 id='catalogue'>Catalogue</h4>

<ol>
<li><a href='#a1'>about va_list</a></li>

<li><a href='#a2'>about regext</a></li>

<li><a href='#a3'>about getopt</a></li>

<li><a href='#a4'>about config_parse</a></li>

<li><a href='#a5'>about shared memory</a></li>

<li><a href='#a6'>about making daemon</a></li>

<li><a href='#a7'>about socket struct</a></li>

<li><a href='#a8'>about select</a></li>
</ol>

<h3 id='code'>Code</h3>

<p>I thought the best way to show you the content of va_list is just list the example code.Below is an example of va_list.</p>
<a name='a1'> </a>
<h4 id='1_about_va_list'>1. about va_list</h4>
<pre class='brush: js;'>
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;string.h&gt;


/*
We have to know that va_list never provide a method to known how many parameters.So if we want to use va_list, we have to provide a way to known the number of the parameters.So for the function below, we provide the number to known the number.
*/
void log_message(int number,  ...) {
    va_list args;
    int i;
    va_start(args, number);
    const char * ptr;
    for (i = 1; i &lt;= number; i++) {
        ptr = va_arg(args, const char *);
        printf("%s\n", ptr);
    }
    va_end(args);
}


/*
May be you would want to try some way like below the get the number of the parameters, but it failed.So don't think in this way again.
*/
void log_message_v2(int number,  ...) {
    va_list args;
    int i;
    va_start(args, number);
    const char * ptr;
    while ((ptr = va_arg(args, const char *)) != NULL) {
        printf("%s\n", ptr);
    }
    va_end(args);
}


int main() {

    
    log_message(2, "hello world", "I miss you");
    log_message_v2(2, "hello world", "I love you");
    return 0;
}
</pre><a name='a2'> </a>
<h4 id='2_about_regext'>2. about regext</h4>
<pre class='brush: js;'>
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;regex.h&gt;
#include &lt;string.h&gt;



static char* substr(const char*str, unsigned start, unsigned end)
{
     unsigned n = end - start;
     static char stbuf[256];
     strncpy(stbuf, str + start, n);
     stbuf[n] = 0;
     return stbuf;
}

int main(int argc, char** argv)
{
    char * pattern;
    int x, z, lno = 0, cflags = 0;
    char ebuf[128], lbuf[256];
    regex_t reg;
    regmatch_t pm[10]; 
    const size_t nmatch = 10;

    pattern = argv[1];
    z = regcomp(&amp;reg, pattern, cflags);
    if (z != 0)
    { 
        regerror(z, &amp;reg, ebuf, sizeof(ebuf));
        fprintf(stderr, "%s: pattern '%s' \n",ebuf, pattern);
        return 1;  
    }

     while(fgets(lbuf, sizeof(lbuf), stdin))
    {
        ++lno;
        if ((z = strlen(lbuf)) &gt; 0 &amp;&amp; lbuf[z-1]== '\n') 
            lbuf[z - 1] = 0; 
 
        z = regexec(&amp;reg, lbuf, nmatch, pm, 0);
        if (z == REG_NOMATCH) 
            continue;
        else if (z != 0) {
            regerror(z, &amp;reg, ebuf, sizeof(ebuf));
            fprintf(stderr, "%s: regcom('%s')\n", ebuf, lbuf);
            return 2;
        }

        for (x = 0; x &lt; nmatch &amp;&amp; pm[x].rm_so != -1; ++ x) {
            if (!x) printf("%04d: %s\n", lno, lbuf);
            printf(" $%d='%s'\n", x, substr(lbuf, pm[x].rm_so,pm[x].rm_eo));
        }

    }

    regfree(&amp;reg); 
    return 0;
}
</pre><a name='a3'> </a>
<h4 id='3_about_getopt'>3. about getopt</h4>
<pre class='brush: js;'>
#include &lt;stdio.h&gt;
#include &lt;getopt.h&gt;
char *l_opt_arg;
char* const short_options = "n:b:l:";
struct option long_options[] = {
     { "name",     1,   NULL,    'n'     },
     { "bf_name",  1,   NULL,    'b'     },
     { "love",     1,   NULL,    'l'     },
     {      0,     0,     0,     0},
};
int main(int argc, char *argv[])
{
     int c;
     while((c = getopt_long (argc, argv, short_options, long_options, NULL)) != -1)
     {
         switch (c)
         {
         case 'n':
             l_opt_arg = optarg;
             printf("My name is %s. \n", l_opt_arg);
             break;
         case 'b':
             l_opt_arg = optarg;
             printf("His name is %s. \n", l_opt_arg);
             break;
         case 'l':
             l_opt_arg = optarg;
             printf("Our love is %s! \n", l_opt_arg);
             break;
         }
     }
     return 0;
}

</pre><a name='a4'> </a>
<h4 id='4_about_config_parse'>4. about config_parse</h4>

<p>First, Below is the code of the function config_parse, Every loop the code read one line,and process this line by involk the function check_match.</p>
<pre class='brush: js;'>
/*
 * Parse the previously opened configuration stream.
 */
static int config_parse (struct config_s *conf, FILE * f)
{
        char buffer[1024];      /* 1KB lines should be plenty */
        unsigned long lineno = 1;

        while (fgets (buffer, sizeof (buffer), f)) {
                if (check_match (conf, buffer)) {
                        printf ("Syntax error on line %ld\n", lineno);
                        return 1;
                }
                ++lineno;
        }
        return 0;
}
</pre>
<p>Ok, Let&#8217;s have a look at the function check_match.And here we can see the important key code.Every loop, the code invoke the function regexec to match .If matched , then invoke relevant function .handler.</p>
<pre class='brush: js;'>
/*
 * Attempt to match the supplied line with any of the configuration
 * regexes defined above.  If a match is found, call the handler
 * function to process the directive.
 *
 * Returns 0 if a match was found and successfully processed; otherwise,
 * a negative number is returned.
 */
static int check_match (struct config_s *conf, const char *line)
{
        regmatch_t match[RE_MAX_MATCHES];
        unsigned int i;

        assert (ndirectives &gt; 0);

        for (i = 0; i != ndirectives; ++i) {
                assert (directives[i].cre);
                if (!regexec
                    (directives[i].cre, line, RE_MAX_MATCHES, match, 0))
                        return (*directives[i].handler) (conf, line, match);
        }

        return -1;
}
</pre>
<p>So, you may want to known what is directives .I have&#8217;t shown its code before.So I list its code below.</p>
<pre class='brush: js;'>
int
config_compile_regex (void)
{
        unsigned int i, r;

        for (i = 0; i != ndirectives; ++i) {
                assert (directives[i].handler);
                assert (!directives[i].cre);

                directives[i].cre = (regex_t *) safemalloc (sizeof (regex_t));
                if (!directives[i].cre)
                        return -1;

                r = regcomp (directives[i].cre,
                             directives[i].re,
                             REG_EXTENDED | REG_ICASE | REG_NEWLINE);
                if (r)
                        return r;
        }

        atexit (config_free_regex);

        return 0;
}
</pre><a name='a5'> </a>
<h4 id='5_about_shared_memory'>5. about shared memory</h4>

<p>Here I list the shared memory means used by this project.Nothing to say, just watch the code.</p>
<pre class='brush: js;'>
/*
 * Initialize the statistics information to zero.
 */
void init_stats (void)
{
        stats = (struct stat_s *) malloc_shared_memory (sizeof (struct stat_s));
        if (stats == MAP_FAILED)
                return;

        memset (stats, 0, sizeof (struct stat_s));
}
</pre>
<p>And from the code before,we known the most important function is malloc_shared_memory.Just see it below.</p>
<pre class='brush: js;'>
/*
 * Allocate a block of memory in the "shared" memory region.
 *
 * FIXME: This uses the most basic (and slowest) means of creating a
 * shared memory location.  It requires the use of a temporary file.  We might
 * want to look into something like MM (Shared Memory Library) for a better
 * solution.
 */
void *malloc_shared_memory (size_t size)
{
        int fd;
        void *ptr;
        char buffer[32];

        static const char *shared_file = "/tmp/tinyproxy.shared.XXXXXX";
        //here, use the temp file for shared memory.
        assert (size &gt; 0);

        strlcpy (buffer, shared_file, sizeof (buffer));

        /* Only allow u+rw bits. This may be required for some versions
         * of glibc so that mkstemp() doesn't make us vulnerable.
         */
        umask (0177);
        //create the temporary file
        if ((fd = mkstemp (buffer)) == -1)
                return MAP_FAILED;
        unlink (buffer);
        //after creating the temporary file, we need to unlink the file to delete it after application is closed.

        //here truncate the file length to size
        if (ftruncate (fd, size) == -1)
                return MAP_FAILED;
        ptr = mmap (NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
        //map the temporary file to the virtual memory space.

        return ptr;
}
</pre><a name='a6'> </a>
<h4 id='6_about_making_daemon'>6. about making daemon</h4>

<p>Nothing to say, just watch the code below.</p>
<pre class='brush: js;'>

/*
 * Fork a child process and then kill the parent so make the calling
 * program a daemon process.
 */
void makedaemon (void)
{
    if (fork () != 0)
        exit (0);

    setsid ();
    set_signal_handler (SIGHUP, SIG_IGN);

    if (fork () != 0)
        exit (0);

    if (chdir ("/") != 0) {
        log_message (LOG_WARNING, "Could not change directory to /");
    }

    umask (0177);
#ifdef NDEBUG
        /*
         * When not in debugging mode, close the standard file
         * descriptors.
         */
        close (0);
        close (1);
        close (2);
#endif
}

</pre><a name='a7'> </a>
<h4 id='7_about_socket_struct'>7. about socket struct</h4>

<h3 id='first_lets_talk_about_getaddrinfo'>First, let&#8217;s talk about getaddrinfo</h3>
<pre class='brush: js;'>
struct addrinfo {
    int              ai_flags;
    int              ai_family;
    int              ai_socktype;
    int              ai_protocol;
    size_t           ai_addrlen;
    struct sockaddr *ai_addr;
    char            *ai_canonname;
    struct addrinfo *ai_next;
};


if (getaddrinfo (config.ipAddr, portstr, &amp;hints, &amp;result) != 0) {
        log_message (LOG_ERR,
                     "Unable to getaddrinfo() because of %s",
                     strerror (errno));
        return -1;
}
/*
getaddrinfo() returns a list of address structures. Try each 
address until we successfully bind(2). If socket(2)(or bind(2)) 
fails , we (close the socket and) try the next address        
*/
for (rp = result; rp != NULL; rp = rp-&gt;ai_next) {
        listenfd = socket (rp-&gt;ai_family, rp-&gt;ai_socktype,
                           rp-&gt;ai_protocol);
        if (listenfd == -1)
                continue;
        //here, call setsockopt to make listenfd SO_REUSEADDR
        //it is important
        setsockopt (listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on,
                    sizeof (on));

        if (bind (listenfd, rp-&gt;ai_addr, rp-&gt;ai_addrlen) == 0)
                break;  /* success */

        close (listenfd);
}

</pre>
<h3 id='then_lets_talk_about_getpeername_and_getnameinfo'>Then let&#8217;s talk about getpeername and getnameinfo</h3>
<pre class='brush: js;'>
struct sockaddr {
    sa_family_t sa_family;
    char        sa_data[14];
}

/*here we get sockaddr from fd */
if (getpeername (fd, (struct sockaddr *) &amp;sa, &amp;salen) != 0)
        return -1;
/*here is just get ip address string*/
if (get_ip_string ((struct sockaddr *) &amp;sa, ipaddr, IP_LENGTH) == NULL)
        return -1;

/* Get the full host name(such as dns name) */
ret = getnameinfo ((struct sockaddr *) &amp;sa, salen,
                    string_addr, HOSTNAME_LENGTH, NULL, 0, 0);

/*
 * Convert the network address into either a dotted-decimal or an IPv6
 * hex string.
 */
char *get_ip_string (struct sockaddr *sa, char *buf, size_t buflen)
{
        assert (sa != NULL);
        assert (buf != NULL);
        assert (buflen != 0);
        buf[0] = '\0';          /* start with an empty string */

        switch (sa-&gt;sa_family) {
        case AF_INET:
                {
                        struct sockaddr_in *sa_in = (struct sockaddr_in *) sa;
                        /*
                            here, we need to known function inet_ntop
                            this is just used to 
                            inet_ntop - convert IPv4 and IPv6 addresses from binary to text form
                        */
                        inet_ntop (AF_INET, &amp;sa_in-&gt;sin_addr, buf, buflen);
                        break;
                }
        case AF_INET6:
                {
                        struct sockaddr_in6 *sa_in6 =
                            (struct sockaddr_in6 *) sa;

                        inet_ntop (AF_INET6, &amp;sa_in6-&gt;sin6_addr, buf, buflen);
                        break;
                }
        default:
                /* no valid family */
                return NULL;
        }

        return buf;
}
</pre>
<p>Then we have another way to get sock from fd,it would be shown below.We need to known function getsockname and getpeername.</p>
<pre class='brush: js;'>
/*
 * Takes a socket descriptor and returns the socket s IP address.
 */
int getsock_ip (int fd, char *ipaddr)
{
        struct sockaddr_storage name;
        socklen_t namelen = sizeof (name);
        assert (fd &gt;= 0);
        if (getsockname (fd, (struct sockaddr *) &amp;name, &amp;namelen) != 0) {
                log_message (LOG_ERR, "getsock_ip: getsockname() error: %s",
                             strerror (errno));
                return -1;
        }
        if (get_ip_string ((struct sockaddr *) &amp;name, ipaddr, IP_LENGTH) ==
            NULL)
                return -1;

        return 0;
}
</pre><a name='a8'> </a>
<h4 id='8_about_select'>8. about select</h4>

<p>Here, we will learn how the tinyproxy use select for proxy function.</p>
<pre class='brush: js;'>

/*
 * Switch the sockets into nonblocking mode and begin relaying the bytes
 * between the two connections. We continue to use the buffering code
 * since we want to be able to buffer a certain amount for slower
 * connections (as this was the reason why I originally modified
 * tinyproxy oh so long ago...)
 *  - rjkaes
 */
static void relay_connection (struct conn_s *connptr)
{
        fd_set rset, wset;
        struct timeval tv;
        time_t last_access;
        int ret;
        double tdiff;
        int maxfd = max (connptr-&gt;client_fd, connptr-&gt;server_fd) + 1;
        ssize_t bytes_received;

        socket_nonblocking (connptr-&gt;client_fd);
        socket_nonblocking (connptr-&gt;server_fd);

        last_access = time (NULL);

        for (;;) {
                FD_ZERO (&amp;rset);
                FD_ZERO (&amp;wset);

                tv.tv_sec =
                    config.idletimeout - difftime (time (NULL), last_access);
                tv.tv_usec = 0;
                /*tinyproxy modify the select set by the buffer size and decide the select whichkind of event to listen*/
                if (buffer_size (connptr-&gt;sbuffer) &gt; 0)
                        FD_SET (connptr-&gt;client_fd, &amp;wset);
                if (buffer_size (connptr-&gt;cbuffer) &gt; 0)
                        FD_SET (connptr-&gt;server_fd, &amp;wset);
                if (buffer_size (connptr-&gt;sbuffer) &lt; MAXBUFFSIZE)
                        FD_SET (connptr-&gt;server_fd, &amp;rset);
                if (buffer_size (connptr-&gt;cbuffer) &lt; MAXBUFFSIZE)
                        FD_SET (connptr-&gt;client_fd, &amp;rset);

                /*select is the key function here, after calling this function,we can known wether the fd is ok */
                ret = select (maxfd, &amp;rset, &amp;wset, NULL, &amp;tv);

                if (ret == 0) {
                        tdiff = difftime (time (NULL), last_access);
                        if (tdiff &gt; config.idletimeout) {
                                log_message (LOG_INFO,
                                             "Idle Timeout (after select) as %g &gt; %u.",
                                             tdiff, config.idletimeout);
                                return;
                        } else {
                                continue;
                        }
                } else if (ret &lt; 0) {
                        log_message (LOG_ERR,
                                     "relay_connection: select() error \"%s\". "
                                     "Closing connection (client_fd:%d, server_fd:%d)",
                                     strerror (errno), connptr-&gt;client_fd,
                                     connptr-&gt;server_fd);
                        return;
                } else {
                        /*
                         * All right, something was actually selected so mark it.
                         */
                        last_access = time (NULL);
                }

                if (FD_ISSET (connptr-&gt;server_fd, &amp;rset)) {
                        bytes_received =
                            read_buffer (connptr-&gt;server_fd, connptr-&gt;sbuffer);
                        if (bytes_received &lt; 0)
                                break;

                        connptr-&gt;content_length.server -= bytes_received;
                        if (connptr-&gt;content_length.server == 0)
                                break;
                }
                if (FD_ISSET (connptr-&gt;client_fd, &amp;rset)
                    &amp;&amp; read_buffer (connptr-&gt;client_fd, connptr-&gt;cbuffer) &lt; 0) {
                        break;
                }
                if (FD_ISSET (connptr-&gt;server_fd, &amp;wset)
                    &amp;&amp; write_buffer (connptr-&gt;server_fd, connptr-&gt;cbuffer) &lt; 0) {
                        break;
                }
                if (FD_ISSET (connptr-&gt;client_fd, &amp;wset)
                    &amp;&amp; write_buffer (connptr-&gt;client_fd, connptr-&gt;sbuffer) &lt; 0) {
                        break;
                }
        }

        /*
         * Here the server has closed the connection... write the
         * remainder to the client and then exit.
         */
        socket_blocking (connptr-&gt;client_fd);
        while (buffer_size (connptr-&gt;sbuffer) &gt; 0) {
                if (write_buffer (connptr-&gt;client_fd, connptr-&gt;sbuffer) &lt; 0)
                        break;
        }
        shutdown (connptr-&gt;client_fd, SHUT_WR);

        /*
         * Try to send any remaining data to the server if we can.
         */
        socket_blocking (connptr-&gt;server_fd);
        while (buffer_size (connptr-&gt;cbuffer) &gt; 0) {
                if (write_buffer (connptr-&gt;server_fd, connptr-&gt;cbuffer) &lt; 0)
                        break;
        }

        return;
}

</pre>

  <address class="signature">
    <a class="author" href="/">YiMeng Yang</a> 
    <span class="date">17 January 2013</span>
    <span class="location"></span>
  </address>
  
  <div class="prev-next">
  
    <a href="/2013/02/02/linux-filesystem" class="next" title="linux filesystem">Next Post &rarr;</a>
  
  
    <a href="/2012/12/21/c-prime-class" class="prev" title="c++ prime class ">&larr; Earlier Post</a>
  
  </div>
  
</div><!-- End Page -->




  
  <div id="footer">
  	<address>
  		<span class="copyright">
  			Content by <a href="/info/site.html">YiMeng Yang</a>. Design by 
  			<a href="http://mark.reid.name/">Mark Reid</a>
  			<br/>
  			(<a rel="licence" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Some rights reserved</a>)			
  		</span>
  		<span class="engine">
  			Powered by <a href="http://github.com/mojombo/jekyll/" title="A static, minimalist CMS">Jekyll</a>
  		</span>
  	</address>
  </div>
  
</div>

<!--[if IE 6]>
<script type="text/javascript"> 
	/*Load jQuery if not already loaded*/ if(typeof jQuery == 'undefined'){ document.write("<script type=\"text/javascript\"   src=\"http://ajax.googleapis.com/ajax/libs/jquery/1.3.2/jquery.min.js\"></"+"script>"); var __noconflict = true; } 
	var IE6UPDATE_OPTIONS = {
		icons_path: "http://static.ie6update.com/hosted/ie6update/images/"
	}
</script>
<script type="text/javascript" src="http://static.ie6update.com/hosted/ie6update/ie6update.js"></script>
<![endif]-->

  

<a id=top-link onclick="goTop();return false;" href="javascript:void(0);"><img src="/images/uparrow.png"  title="返回顶部" /></a> 



</body>
</html>

